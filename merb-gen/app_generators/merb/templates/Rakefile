require 'rubygems'
Gem.clear_paths
Gem.path.unshift(File.join(File.dirname(__FILE__), "gems"))

require 'rake'
require 'rake/rdoctask'
require 'rake/testtask'
require 'spec/rake/spectask'
require 'fileutils'
require 'merb-core'
require 'rubigen'

$RAKE_ENV = true

Merb.start :environment => (ENV['MERB_ENV'] || 'development'),
           :adapter     => 'runner',
           :merb_root  => File.dirname(__FILE__)
           
include FileUtils
# # # Get Merb plugins and dependencies
Merb::Plugins.rakefiles.each {|r| require r } 

# 
#desc "Packages up Merb."
#task :default => [:package]

desc "load merb_init.rb"
task :merb_init do
  require 'merb-core'
  require File.dirname(__FILE__)+'/config/init.rb'
end  

task :uninstall => [:clean] do
  sh %{sudo gem uninstall #{NAME}}
end

desc 'Run all tests, specs and finish with rcov'
task :aok do
  sh %{rake rcov}
  sh %{rake spec}
end

unless Gem.cache.search("haml").empty?
  namespace :haml do
    desc "Compiles all sass files into CSS"
    task :compile_sass do
      gem 'haml'
      require 'sass'
      puts "*** Updating stylesheets"
      Sass::Plugin.update_stylesheets
      puts "*** Done"      
    end
  end
end

##############################################################################
# SVN
##############################################################################

desc "Add new files to subversion"
task :svn_add do
   system "svn status | grep '^\?' | sed -e 's/? *//' | sed -e 's/ /\ /g' | xargs svn add"
end


class Freezer
  
  class << self

    # Avalaible components and their respective git repository URIs.
    def components
      {
        'core'    => 'git://github.com/wycats/merb-core.git',
        'more'    => 'git://github.com/wycats/merb-more.git',
        'plugins' => 'git://github.com/wycats/merb-plugins.git'
      }
    end

    # Directory in which components are saved.
    # Default is set to +framework+
    # NOTE: should the framework directory be coustomizable?
    def framework_dir
      File.join(File.dirname(__FILE__), "framework")
    end

    # Try to freeze +component+ into +framework_dir+
    #
    # ==== Parameters
    # component<String>::
    #   Name of the component to freeze. 
    #   Can be one of +core+, +more+ or +plugins+. 
    # update<Boolean>:: 
    #   If true, we'll try to update the component if already managed
    #   Default is false.
    def freeze(component, update=false)
      freezer = new(component, update)
      freezer.freeze
    end

  end

  def initialize(component, update)
    @component = 'merb-' + component
    @update = update
    @component_directory = File.join(File.basename(Freezer.framework_dir), @component)
  end
  
  def freeze
    # Ensure that the current directory is a git repository
    abort('ERROR: Not a git repository') unless git?

    # Ensure that required git commands are available
    %w(git-pull git-submodule).each do |bin|
      next if in_path?(bin)
      $stderr.puts "ERROR: #{bin} must be available in PATH"
      exit 1
    end

    case status
    when :managed
      puts "#{@component} seems to be already managed by git-submodule."
      if @update
        puts "Updating #{@component} ..."
        sh "cd #{@component_directory} && git-pull origin master"
        sh "git-submodule update #{@component_directory}"
      else
        puts "Set UPDATE to true if you want to update #{@component}."
      end
    when :not_managed
      unless File.directory?(Freezer.framework_dir)
        puts "Creating framework directory ..."
        FileUtils.mkdir_p(Freezer.framework_dir)
      end
      puts "Creating submodule for #{@component} ..."
      sh "git-submodule --quiet add #{Freezer.components[@component.gsub('merb-', '')]} \
        #{File.basename(Freezer.framework_dir)}/#{@component}" 
      abort("Unable to create submodule for #{@component}") unless $?.success?
      sh "git-submodule init #{File.basename(Freezer.framework_dir)}/#{@component}"
    when :unitialized # OK
      puts "Initializing #{@component} ..."
      sh "git-submodule update #{@component_directory}"
    when :need_update then sh "git-submodule update #{@component_directory}"
    end
  end

  protected

  # Returns component's status by reading the output of +git-submodule status+.
  #
  # Status can be one the fellowing :
  # * +managed+: component is properlty managed
  # * +not_managed+: component doesn't appears into command's output
  # * +unitialized+: component is managed but not initialized
  # * +need_update+:
  #   The currently checked out submodule commit
  #   does not match the SHA-1 found in the index of the containing repository.
  #
  # ==== Returns
  # Symbol:: The status of component's submodule
  def status
    status = `git-submodule status`
    prefix = status =~ /^(\s|\+|-)\w+ #{File.basename(Freezer.framework_dir)}\/#{@component}/im && $1
    return case prefix
    when ' ' then :managed
    when '-' then :unitialized
    when '+' then :need_update
    else
      :not_managed
    end
  end

  # Check that +bin+ is avalaible in path using +/bin/which+.
  #
  # ==== Parameters
  # String:: Name of the program.
  #
  # ==== Returns
  # Boolean:: Availability of +bin+.
  def in_path?(bin)
    `which #{bin}`
    !$?.nil? && $?.success?
  end

  # Ensure that the current directory is a git repository
  # using +git-status+
  # 
  # ==== Returns
  # Boolean:: Is it a git repository?
  def git?
    `git-status`
    $?.exitstatus != 128
  end
end

task :freeze => Freezer.components.keys.map { |component| "freeze:#{component}" }
namespace :freeze do
  Freezer.components.each do |component, git_repository|
    desc "Freeze #{component} from #{git_repository}"
    task component do
      Freezer.freeze(component, !!ENV['UPDATE'])
    end
  end
end
